ATL.

ATL - это язык описания анимаций и трансформаций.
Во многом похож на ScreenLang, команды выполняются друг за другом.

Может быть использован в 3-х случаях:
1. При объявлении изображения:
	image np smile = "images/sprites/np/np_smile.png":
		xysize (0.3, 1.0)
2. При показе, используя параметр at:
	show np smile at left
3. При показе, используя синтаксис 1-го способа:
	show np smile:
		pos (0.28, 1.0)   # По сути, это именно то, что и делает left после at
		anchor (0.5, 0.5)

Разумеется, никто не запрещает использовать эти способы одновременно к одному изображению.
Порядок выполнения: ровно тот, что показан выше.
Если 2 и 3 способ не используются, то на месте 2-го используется center.


Если не используется 1-й способ, то на его месте используется default_decl_at.
Эта переменная - список команд (по-умолчанию пуст), пример использования (в init-секции):
	$ default_decl_at = ["xysize (1.0, 1.0)"]
	# Все объявленные дальше изображения будут растянуты/сжаты так, чтобы занимать всё окно.
	
	image bg some1 = "images/image.png"
	image bg some2 = "images/other_image.jpg"
	image bg some3 = "images/also_image.png"
	
	# Здесь это надо добавить в ручную, т. к. 1-й способ всё же используется.
	image bg with_alpha = "images/some_image.png":
		alpha 0.6
		xysize (1.0, 1.0)
	
	$ default_decl_at = []
	# Возвращаем назад, чтобы объявленные дальше картинки не растягивались.



Свойства:

alpha, rotate
xpos, ypos, pos
xanchor, yanchor, anchor
xalign, yalign, align
xsize, ysize, xysize
crop

Все эти свойства из ScreenLang доступны (+ есть xcrop, ycrop, xsizecrop, ysizecrop).
И всё так же можно (если вдруг сильно надо) написать их в одну строку:
	show np smile:
		xpos 0.28 ypos 1.0


Пауза:
Точно так же, как и внутри label: pause 1.5
Ну или просто 1.5 (команда считается за время паузы, если при её выполнении как python-кода в результате получается число: int или float)


Плавное изменение свойств:

Если первым параметром в строке идёт функция, то считается, что сейчас идёт плавное изменение (тогда 2-м параметром считается время).
Например, так можно передвинуть изображение слева направо:
	xalign 0.0
	linear 1.5 xalign 1.0

Кроме linear есть ещё ease, easein и easeout.
Можно использовать и свою функцию: она должна принимать число от 0 (начало анимации) до 1 (конец) и выдавать число от 0 (начальные координаты) до 1 (конечные).
Например:
	linear выдаёт то же самое, что и получает (отсюда и линейность),
	ease ведёт себя по-другому, она такова: return 0.5 - math.cos(math.pi * t) / 2.0.


Параллельное исполнение:

Если поставить команды друг за другом, то они будут выполняться по очереди, но это может быть нежелательно (например, если используются плавные изменения).
Тогда можно сделать так:
	parallel:
		xalign 0.0
		linear 1 xalign 1.0
		linear 1 xalign 0.0
		repeat
	parallel:
		yalign 1.0
		linear 3 yalign 0.0
		linear 3 yalign 1.0
		repeat

Исполнение parallel считается завершённым, если все parallel-блоки были завершёны.


Повтор:

Как можно было увидеть в предыдущем примере, можно вернуться к первой команде текущего блока, использовав repeat.
Если после этого указать число (repeat 3, например), то это будет считаться за количество повторов.
После указанного количества будет произведён переход на команду после этого repeat (если там дальше что-то есть), а количество повторов во всех предыдущих repeat будет обнулено, например:
	xalign 0.0
	linear 2 xalign 1.0
	linear 2 xalign 0.0
	repeat 2
	yalign 1.0
	repeat
Тут будет плавное перемещение вправо, потом влево, потом повтор этого ещё 2 раза, потом мгновенное перемещение вниз (по-умолчанию сначала yalign был равен нулю, т. е. объект был сверху), потом повтор всего этого неограниченное число раз (но перемещения наверх нет, т. е. всё уже будет внизу).

На самом деле, у меня большие сомнения в том, что кто-то будет использовать в одном блоке несколько repeat, но такое поведение кажется мне довольно логичным, вот я его и объяснил (в Ren'Py поведение другое).


Блок команд:
	block:
		# Тут какие угодно команды.
	Выполнение считается завершённым после выполнения всех команд внутри блока.


Несколько изображений сразу:
	contains "images/some_bg.jpg":
		xysize (1.0, 1.0)
	contains "images/some_object.png":
		pos (0.2, 0.4)
		xysize (0.3, 0.8)
	contains "images/other_object.png":
		pos (0.5, 0.4)
		xysize (0.3, 0.8)
	
	Команда contains удаляет все предыдущие изображения в текущем (за исключением всех предыдущих команд contains, идущих подряд относительно текущей).
	Все contains создают новые изображения внутри текущего, они являются его потомками, их параметры (позиция, прозрачность...) вычисляются относительно его (короче, в данном случае, всё как в ScreenLang).
	Кстати, то, что идёт после contains, считается за первую команду, т. е. можно первый блок из примера выше переписать так:
		contains:
			"images/some_bg.jpg"
			xysize (1.0, 1.0)
	И при этом ничего не изменится.


Собственно, сами изображения:
	Как можно было увидеть из примера выше, сами изображения указываются обычной строкой python-кода.
	Самый простой способ - просто взять в кавычки путь к изображению.
	Но, разумеется, можно использовать и другие методы, например, что-то типа этого:
		image bg some_image:
			"images/some_" + config.lang + "_bg.png"
	Или вместо пути к файлу изображения можно вставить имя зарегистрированной картинки, тогда на место текущей строки будут вставлены все команды этого изображения (кстати, то, что идёт после знака = в команде image (регистрация изображения), считается первой командой этого изображения):
		image bg eng_image = "images/some_eng_bg.png"
		image bg cool_image:
			"bg some_image"
			pause 1
			"bg eng_image"
			pause 1
			repeat
	И, разумеется, добавление изображения таким образом убирает предыдущее изображение и все contains.

