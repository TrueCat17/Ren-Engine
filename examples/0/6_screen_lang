ScreenLang.

ScreenLang - это язык описания графического интерфейса.
Интерфейс строится из набора компонентов, которые можно разделить на 2 группы: простые компоненты и контейнеры.


Перед началом:
Указание любого свойства любого компонента можно сделать так:
	comp [main_param] param1 value1 param2 value2
Так:
	comp [main_param] param1 value1:
		param2 value2
Или так:
	comp [main_param]:
		param1 value1
		param2 value2
А если поменять строки с указанием параметров местами, то абсолютно ничего не поменяется, кроме порядка вычисления параметров.
Ну и количество указываемых параметров, разумеется, не ограничено.



Начнём с простых:


$, python - используются как обычно.


Клавиатура:

key KEY action action_func
Где KEY - строка, обозначающая клавишу на клавиатуре:
		Например: проблел - "SPACE", Enter - "RETURN", стрелка влево - "LEFT", F1 - "F1", W - "w",
		Если присутствует префикс "K_", то он удаляется автоматически, т. е. "K_LEFT" тоже будет работать.
	action_func - функция, которая будет выполнена при нажатии на клавишу.
Также есть настройка параметров first_delay (игнорирование нажатий после первого в течение некоторого времени) и delay (после второго и далее).
Это время указывается в секундах, по-умолчанию 0.333 и 0.010 соответственно.

Пример:
Где-то в init-блоке:
	python:
		def my_func(a = None):
			print a

Теперь попробуем вызвать эту функцию при нажатии на Enter:
	key "RETURN" action my_func
И действительно, при нажатии на Enter будет напечатано None.

Но часто бывает, что нам желательно бы передать этой функции параметры, это можно сделать так:
	key "RETURN" action my_func(5)
Тут будет вызван результат выполнения функции my_func, а т. к. мы ничего не возвращаем или, говоря иначе, возвращаем None, этот None будет проигнорирован.

Но можно всё это дело обернуть:
	key "RETURN" action Function(my_func, 5)
Function - это класс, который при создании своего экземпляра запоминает переданные функцию и её аргументы, а при вызове - вызывает эту функцию с нужными аргументами.
Так же есть SetVariable("var_name", value) и AddVariable("var_name", value), которые устанавливают переменной var_name значение value (Add - добавляет).
Пример:
	$ my_var = 123
	key "SPACE" action AddVariable("my_var", 321)
	$ print my_var

Ещё следует сказать, что вместо функции в action можно передать список функций.
Но тут следует быть осторожным, потому что всё указанное выше (кроме прямого вызова) - обёртки над функциями, а не реальные вызовы.
Сначала создаются все обёртки (т. е. запоминаются все параметры), а уже потом оно начинает исполняться, и результат этих функций будет неизменным.
Например, вот этот код выдаст ошибку, потому что на момент создания экземпляра класса Function переменной qwe ещё не существует, а он уже пытается её запомнить, чтобы использовать после SetVariable:
	key action [SetVariable("qwe", 23), Function(my_func, qwe)]
Разумеется, так будет, только если вы не создали переменную qwe заранее, в этом случае всё становится ещё хуже - Function берёт старое значение переменной, и вы даже не узнаете о том, что тут вообще-то ошибка, и код делает не то, что вы от него ожидаете.
Так что при работе со списком функций следует быть очень осторожным, т. к. тут очень легко допустить ошибку.


Текст:

text TEXT
Где TEXT - отображаемое значение (ожидается тип str).
У текста можно настроить ещё чисто-текстовые свойства:
	font - имя файла TTF-шрифта, который располагается в resources/fonts/ (без расширения, примеры: "Calibri", "Arial"),
	color - цвет в формате 0xRRGGBB,
	text_size (не путать с size) - размер шрифта,
	text_align - выравнивание строк текста по-горизонтали, допустимы "left", "center", "right",
	text_valign - выравнивание строк по-вертикали (если точнее, расположение строк в текстовом поле), допустимы "top", "center", "down".


Кнопка с текстом и обычная кнопка:

textbutton TEXT action action_func # с текстом
button action action_func # без текста
Где TEXT - отображаемый текст,
	action_func - аналогично key.
Свойства для отображения:
	ground - фон кнопки в обычном состоянии,
	hover  - фон кнопки, когда на неё наведена мышь.
Если мышь наведена на полностью прозрачный пиксель изображения, то она не считается наведённой.
Для избегания такого поведения используйте около-нулевую непрозрачность вместо нулевой. Для пользователя такое не должно быть заметно.
Также для текстовой кнопки доступны все текстовые настройки.
И ещё: вы вряд ли сможете это хоть как-то использовать, но обычная кнопка - это текстовая кнопка с пустым текстом.

Дополнительные свойства кнопок:
	action    - действие, выполняемое при нажатии Левой Кнопки Мыши,
	alternate - действие, выполняемое при нажатии Правой Кнопки Мыши,
	hovered   - действие, выполняемое при наведении на кнопку,
	unhovered - действие, выполняемое при убирании курсора с кнопки,
	
	active_sound - звук, проигрываемый на канале "button_click" при клике Левой Кнопки Мыши,
	hover_sound  - звук, проигрываемый на канале "button_hover" при наведении на кнопку,
	
	mouse - True/False, определяет,
		нужно ли использовать на кнопке "наведённый" курсор мыши
		и считать нажатие <Space> и <Enter> как клик ЛКМ
		(при False не использует и не считает)



Контейнеры:


if, elif, else, for, while (внутри циклов по-прежнему могут использоваться break и continue, else всё так же доступна после циклов)
Это может показаться странным, но всё только что перечисленное - контейнеры, хоть и несколько необычные.
Они добавляют потомков не в себя, а в своего родителя (а родитель может добавить его в своего родителя, а не в себя, если тоже принадлежит к этой группе фейк-контейнеров).
При создании такого контейнера создаются все нужные для данного кадра потомки.
Если в следующем кадре их количество увеличивается (например, в цикле for i in xrange(my_var) значение my_var больше, чем в предыдущем кадре, или условие стало истинным, а раньше всегда было ложным), то и недостающие потомки создаются.
Если уменьшается - ненужные в данном кадре потомки отключаются (не происходит обновления свойств и отрисовки) и включатся только когда это понадобится.
Т. е. всё работает так, как и ожидается интуитивно.
Но помнить о том, что это всё-таки не просто условия/циклы, а всё же контейнеры, может быть полезно.
Например, если вы собираетесь делать 10 условий внутри цикла с тысячей итераций, то лучше всё же этого не делать и попытаться это дело оптимизировать.
Допустим, у нас есть такой сильно упрощённый (и от этого даже несколько нелепый) пример:
for i in xrange(1000):
	if i < 100:
		image 'images/some_dir/000+.png'
	elif i < 200:
		image 'images/some_dir/100+.png'
#	...
	else:
		image 'images/some_dir/900+.png'
Если задуматься, то тут создаётся 1000 * 10 = 10000 условий и 1000 изображений.
Ну, 1000 изображений, допустим, нам реально необходимы (например, у нас игра с кучей зомби, или мы хотим устроить красивый снегопад).
А вот избавиться от кучи условий вполне возможно (тем более, что их значительно больше, а потому в первую очередь избавляться нужно от них).

Конкретно в этом случае можно написать всё более кратко, но вряд ли часто будет нужно именно это, поэтому я опишу то, что будет работать для более общего случая:
python:
	images = []
	for i in xrange(1000):
		if i < 100:
			path = 'images/some_dir/000+.png'
		elif i < 200:
			path = 'images/some_dir/100+.png'
#		...
		else:
			path = 'images/some_dir/900+.png'
		images.append(path)

for path in images:
	image path

Как видите, мы перенесли все условия в блок питон-кода и создали в нём список путей к изображениям, а в цикле без всяких условий создали все нужные изображения.
Это работает гораздо быстрее, т. к. в данном случае условия и циклы - это реально условия и циклы, которые к тому же находятся в одном блоке.

Это уже - оптимизация, влияющая на читаемость кода.
Она может её как улучшить, так и ухудшить, поэтому пытайтесь сохранить в первую очередь её (читаемость), и если она страдает слишком сильно, и всё слишком запутывается, а вам нужно отрисовать лишь десяток объектов - не используйте оптимизацию.
Ещё раз повторю: если у вас производительность не страдает - ставьте лёгкость понимания кода на первое место.
Кстати, это относится ко всему коду, а не только к ScreenLang.


Изображение:
image IMAGE
Где IMAGE - путь к изображению (применимо и то, что описывалось в соответствующей главе).

Тут следует упомянуть вот о чём.
Допустим, у вас есть что-то типа такого (упрощённо):
	image im.Scale('images/some_dir/some_name.png', 200, 100)
Так вот, не стоит так делать, лучше будет (не всегда, но в большинстве случаев) переписать это следующим образом:
	image 'images/some_dir/some_name.png':
		size (200, 100)
О свойстве size, как и о других общих свойствах, будет рассказано в конце этой главы.
Причина, почему это лучше - не будет создана ещё одна текстура, которая будет отличаться от оригинальной лишь размером.
Это - более оптимальное использование кэша (вы же ведь разобрались с ним и всё помните, не так ли?).
Во время отрисовки изображение будет растянуто так, как указано (если не указано, то растяжения/сжатия не будет).
Растяжение с помощью size (и подобными) почти совсем-совсем не сказывается на производительности.


imagemap и hotspot:
Можно лишь условно назвать imagemap контейнером, потому что единственный объект, который он может содержать - hotspot.
Он же, в свою очередь, может быть добавлен только в imagemap (а содержать вообще ничего не может).
Итак, imagemap виден как изображение, которое указано в его свойстве ground.
При наведении мыши на область (на непрозрачный пиксель), указанную в одном из hotspot'ов,
поверх этой области рисуется изображение, указанное в свойстве hover.
Свойства ground и hover очень похожи на соответствующие у кнопок.
Элемент hotspot имеет свою область в imagemap (x, y, ширина, высота) и свойство action (а так же остальные кнопочные свойства).
Пример использования:
imagemap:
	ground 'images/menu/ground.png'
	hover  'images/menu/hover.png'
	
	hotspot (50, 50, 200, 25) action Function(start_mod, 'main_game')
	hotspot (50, 75, 200, 25) action exit_from_game


vbox, hbox:
Это контейнеры, которые автоматически располагают элементы внутри себя (vbox - в столбец, hbox - в линию).
Имеют свойство spacing, которое определяет расстояние между объектами (по-умолчанию 0).
Пример:
vbox:
	spacing 15
	
	textbutton "Играть"    action Function(start_mod, 'main_game')
	textbutton "Настройки" action ShowMenu('settings')
	textbutton "Выход"     action exit_from_game


null:
Ничто, пустота.
Имеет размеры: в отличие от Ren'Py, не width и height, а xsize и ysize (или сразу size, об этом позже).
Имена этих свойств изменены для большей логичности и стандартизации.
Может использоваться и в качестве контейнера.
Например, так можно сделать область в четверть экрана и расставить по её углам картинки:
null:
	size (0.5, 0.5)
	
	image img align (0.0, 0.0)
	image img align (0.0, 1.0)
	image img align (1.0, 0.0)
	image img align (1.0, 1.0)


use:
Позволяет использовать указанный скрин в качестве элемента интерфейса.
Например, use fps - включить скрин fps в текущий скрин (без кавычек).
Рекурсивное включение скринов дуг в друга недопустимо.

screen:
Собственно, самый верхний узел во всей этой иерархии.
Помимо остальных, имеет также свойство has, которое позволяет превратить скрин в соответствующий авто-контейнер (has vbox или has hbox).
Кроме него имеет и все остальные общие свойства объектов ScreenLang (alpha, rotate, pos, anchor и прочие, благодаря чему можно, например, повернуть или сместить сразу весь скрин всего одной строчкой).

В отличие от Ren'Py, здесь весь python-код в скринах выполняется в глобальном пространстве имён (т. е. так, как это и ожидается по-умолчанию).
С одной стороны, это вызывает некоторые неудобства, например, такой код может работать не так, как от него ожидается:
label some_label:
	$ i = 100 + 23
	# В этом месте может начаться отрисовка скринов,
	# если какой-нибудь из них использует переменную i,
	# то её значение, разумеется, уже не будет равно 123
	np "100 + 23 = " + str(i)
С другой стороны, на мой взгляд это всё же лучше, чем чуть ли не в каждом блоке python-кода писать кучу global'ов.

Ну а т. к. скрины не имеют локальных пространств имён, то они не имеют и передаваемых параметров (типа use some_screen('qwe', i * 2)).
Хотя вообще-то их можно было бы сделать и без локальных пространств имён, но это нередко приводило бы к трудноуловимым багам.



Свойства:


alpha 0.75 # Непрозрачность (0 - полностью прозрачно, 1.0 - полностью видимо)
rotate 45  # Поворот по часовой стрелке, в градусах


xpos 10 # координата по оси X в пикселях (0 - самая левая точка)
ypos 15 # Y-координата (0 сверху)
pos (10, 15) # более компактная форма записи 2-х предыдущих строк


xanchor 50 # X-координата в объекте, которая будет считаться началом, точкой отсчёта
Например, если xpos == 750, а xanchor == 650, то фактически объект будет рисоваться, начиная с X-координаты 100.
Аналогично для yanchor.
anchor (50, 75) # установка xanchor и yanchor одной строкой


xsize 100 # ширина объекта
ysize 50  # высота
size (100, 50) # установка xsize и ysize
Не стоит путать size с text_size, т. к. последнее отвечает за размер шрифта в текстовом поле.

Если размер не задан явно, то он вычисляется.
Размер vbox и hbox вычисляется так (на примере vbox):
	Ширина - максимум среди ширины всех вложенных объектов,
	Высота - сумма высот всех объектов + учёт расстояния (spacing) между ними.
Аналогично, но наоборот, вычисляется размер hbox.
Размер текстового поля вычисляется похожим образом, но вместо вложенных объектов там строки.


xalign 0.5 # размещение по центру оси X в родительском контейнере
yalign 1.0 # размещение снизу экрана
align (0.5, 1.0) # сокращённая запись
Как это работает:
	xalign  1.0
	# это сокращённая запись для:
	xpos    1.0 # помещаем в правый край экрана,
	xanchor 1.0 # ставим в качестве "нулевой точки" объекта его правый край
	# Т. е. мы ставим самый правый пиксель объекта в самый правый пиксель экрана

Если тип xpos - float, то это значение умножается на длину окна.
В случае Y - на ширину.
Это действует на все эти группы свойств (pos, anchor, size).
Обратите внимание, что в случае с pos и size умножение идёт на длину и ширину _окна_, а не родительского контейнера.
Иначе такие штуки было бы непонятно как вычислять и их пришлось бы запретить:
hbox:
	textbutton "Click Me!" xsize 0.9
Т. к. 0.9 было бы относительно ширины родительского контейнера, но она зависит от ширины этой кнопки.
Хотя можно было считать, что все эти размеры просто равны нулю, но в этом не было бы абсолютно никакого смысла.
А если брать в расчёт не такие примитивные случаи, то мы бы получили ещё и кучу "магии", когда объект исчезает непонятно почему, непонятно куда и непонятно во что.
В случае с anchor - умножение идёт на размер текущего объекта.

И на всякий случай уточню, что свойства alpha, rotate и pos у объектов наследуются от "родителей", в которых они вложены.
image parent_image:
	rotate 45
	alpha 0.5
	xpos 1000
	
	image child_image:
		rotate 135 # 135 + 45 = 180
		alpha  0.5 # 0.5 * 0.5 = 0.25
		xpos  -200 # так просто не вычислить, нужно учитывать поворот

Также у объектов image, imagemap, button и textbutton есть свойство crop - список из 4-х значений, которые указывают, какую часть текстуры отрисовывать.
По-умолчанию это (0.0, 0.0, 1.0, 1.0) - (x, y, ширина, высота).
Числа в этом списке домножаются на ширину (x и ширина) и высоту (y и высота) текстуры, если они являются float'ами.
Надо заметить, что это свойство не влияет на размер отрисовываемого объекта, а лишь указывает, какую часть текстуры нужно отрисовать.


Стили:

Если какое-то свойство объекта не задано в явной форме, то оно берётся из его стиля.
Они хранятся в объекте style (см. resources/mods/engine/style.rpy).
Компонент типа text по-умолчанию имеет стиль text, image - стиль image и т. д.
Но можно создать свой стиль (как это сделать - см. в файле, что указан выше) и указать его, тогда недостающие свойства будут браться из него, а прежний стиль будет игнорироваться.
Указать стиль можно свойством style, например:
image 'some_image.png':
	style my_super_style # внимание, без кавычек!
	anchor (0.5, 0.5)
Но для этого стиль my_super_style должен быть создан как-то так:
	style.my_super_style = Style(style.image)
	style.my_super_style.xpos = 10
	style.my_super_style.ypos = 10
	style.my_super_style.xsize = 50
	style.my_super_style.ysize = 50
В файле style.rpy это написано, но на всякий случай повторю и тут:
Использовать в стилях свойства pos, anchor, xalign, yalign, align, size - нельзя.

В силу того, что стили редко изменяются (а по-хорошему они вообще не должны изменяться), значение каждого свойства берётся лишь один раз за запуск мода, далее при всех запросах к этому свойству будет использоваться именно кэшированное значение, полученное в первый раз.
(Раньше кэширование было в пределах отрисовываемого кадра, а не всего запущенного мода, но из-за этого производительность была ниже на 10%, поэтому от этого было решено отказаться.)

Кстати, везде выше, где говорилось "не задано по-умолчанию" применительно к [x/y/]size, имелось ввиду "после вычисления результат <= 0".
А не то, что хранится в стиле по-умолчанию.
Т. е. если вы измените размер по-умолчанию в стиле, то можете легко поломать много вещей.
Поэтому подумайте трижды, прежде чем сделать это.

