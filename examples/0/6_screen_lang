ScreenLang.

ScreenLang - это язык описания графического интерфейса.
Интерфейс строится из набора компонентов, которые можно разделить на 2 группы: простые компоненты и контейнеры.


Перед началом:
Указание любого свойства любого компонента можно сделать так:
	comp [main_param] param1 value1 param2 value2
Так:
	comp [main_param] param1 value1:
		param2 value2
Или так:
	comp [main_param]:
		param1 value1
		param2 value2
А если поменять строки с указанием параметров местами, то абсолютно ничего не поменяется.
Ну и количество указываемых параметров, разумеется, не ограничено.



Начнём с простых:


$, python - используются как обычно.


Клавиатура:

key KEY action action_func
Где KEY - строка, обозначающая клавишу на клавиатуре:
		Например: проблел - "SPACE", Enter - "RETURN", стрелка влево - "LEFT", F1 - "F1", W - "w",
		Если присутствует префикс "K_", то он удаляется автоматически, т. е. "K_LEFT" тоже будет работать.
	action_func - функция, которая будет выполнена при нажатии на клавишу.
Также есть настройка параметров first_delay (игнорирование нажатий после первого в течении некоторого времени) и delay (после второго и далее)
Это время указывается в секундах, по-умолчанию 0.333 и 0.010 соответственно:

Пример:
Где-то в init-блоке:
	python:
		def my_func(a = None):
			print a

Теперь попробуем вызвать эту функцию при нажатии на Enter:
	key "RETURN" action my_func
И действительно, при нажатии на Enter будет напечатано None.

Но часто бывает, что нам желательно бы передать этой функции параметры, и делать это так будет ошибкой:
	key "RETURN" action my_func(5)
Потому как тут будет вызван результат выполнения функции my_func, а т. к. мы ничего не возвращаем, нам будет выдана ошибка о том, что нельзя вызвать None (результат my_func(5)) как функцию.

Поэтому нам надо всё это дело обернуть, чтобы оно работало так, как ожидается:
	key "RETURN" action Function(my_func, 5)
Function - это класс, который при создании своего экземпляра запоминает переданные функцию и её аргументы, а при вызове - вызывает эту функцию с нужными аргументами.
Так же есть SetVariable("var_name", value) и AddVariable("var_name", value), которые устанавливают переменной var_name значение value (Add - добавляет).
Пример:
	$ my_var = 123
	key "SPACE" action AddVariable("my_var", 321)
	$ print my_var

Ещё следует сказать, что вместо функции в action можно передать список функций.
Но тут следует быть осторожным, потому что всё указанное выше - обёртки над функциями, а не реальные вызовы.
Сначала создаются все обёртки (т. е. запоминаются все параметры), а уже потом оно начинает исполняться, и результат этих функций будет неизменным.
Например, вот этот код выдаст ошибку, потому что на момент создания экземпляра класса Function переменной qwe ещё не существует, а он уже пытается её запомнить, чтобы вызвать после SetVariable:
	key action [SetVariable("qwe", 23), Function(my_func, qwe)]
Разумеется, так будет, только если вы не создали переменную qwe заранее, в этом случае всё становится ещё хуже - Function берёт старое значение переменной, и вы даже не узнаете о том, что тут вообще-то ошибка, и код делает не то, что вы от него ожидаете.
Так что при работе со списком функций следует быть очень осторожным, т. к. тут очень легко допустить ошибку.


Текст:

text TEXT
Где TEXT - отображаемое значение (автоматически приводится к типу str).
У текста можно настроить ещё чисто-текстовые свойства:
	font - имя файла TTF-шрифта, который располагается в resources/fonts/ (без расширения, примеры: "Calibri", "Arial"),
	text_size (не путать с size) - размер шрифта,
	color - цвет в формате "#RRGGBB",
	text_align - выравнивание строк текста по-горизонтали, допустимы "left", "center", "right",
	text_valign - выравнивание строк по-вертикали (если точнее, расположение строк в текстовом поле), допустимы "top", "center", "down".


Кнопка с текстом и обычная кнопка:

textbutton TEXT action action_func
button action action_func
Где TEXT - отображаемый текст,
	action_func - аналогично key.
У кнопок есть чисто-кнопочные свойства:
	ground - фон кнопки в обычном состоянии,
	hover - фон кнопки, когда на неё наведена мышь.
Если мышь наведена на полностью прозрачный пиксель изображения, то мышь не считается наведённой, если хотите избежать такого поведения - используйте около-нулевую непрозрачность вместо нулевой. Для пользователя такое не должно быть заметно.
Также для текстовой кнопки доступны все текстовые настройки.
И ещё: вы вряд ли сможете это хоть как-то использовать, но обычная кнопка - это текстовая кнопка с пустым текстом.



Контейнеры:


if, elif, else, for, while (внутри циклов по-прежнему могут использоваться break и continue, else всё так же доступна после циклов)
Это может показаться странным, но всё только что перечисленное - контейнеры, хоть и несколько необычные.
Они добавляют потомков не в себя, а в своего родителя (а родитель может добавить его в своего родителя, а не в себя, если тоже принадлежит к этой группе фейк-контейнеров).
При создании такого контейнера создаются все нужные для данного кадра потомки.
Если в следующем кадре их количество увеличивается (например, в цикле for i in xrange(my_var) значение my_var больше, чем в предыдущем кадре, или условие стало истинным, а раньше всегда было ложным), то и недостающие потомки создаются.
Если уменьшается - ненужные в данном кадре потомки отключаются (не происходит обновления свойств и отрисовки) и включатся только когда это понадобится.
Т. е. всё работает так, как и ожидается интуитивно.
Но помнить о том, что это всё-таки не просто условия/циклы, а всё же контейнеры, может быть полезно.
Например, если вы собираетесь делать 10 условий внутри цикла с тысячей итераций, то лучше всё же этого не делать и попытаться это дело оптимизировать.
Допустим, у нас есть такой сильно упрощённый (и от этого даже несколько нелепый) пример:
for i in xrange(1000):
	if i < 100:
		image 'images/some_dir/000+.png'
	elif i < 200:
		image 'images/some_dir/100+.png'
#	...
	else:
		image 'images/some_dir/900+.png'
Если задуматься, то тут создаётся 1000 * 10 = 10000 условий и 1000 изображений.
Ну, 1000 изображений, допустим, нам реально необходимы (например, у нас игра с кучей зомби, или мы хотим устроить красивый снегопад).
А вот избавиться от кучи условий вполне возможно (тем более, что их значительно больше, а потому в первую очередь избавляться нужно от них).

Конкретно в этом случае можно написать всё более кратко, но вряд ли часто будет нужно именно это, поэтому я опишу то, что будет работать для более общего случая:
python:
	images = []
	for i in xrange(1000):
		if i < 100:
			path = 'images/some_dir/000+.png'
		elif i < 200:
			path = 'images/some_dir/100+.png'
#		...
		else:
			path = 'images/some_dir/900+.png'
		images.append(path)

for path in images:
	image path

Как видите, мы перенесли все условия в блок питон-кода и создали в нём список путей к изображениям, а в цикле без всяких условий создали все нужные изображения.
Это работает гораздо быстрее, т. к. в данном случае условия и циклы - это реально условия и циклы, которые к тому же находятся в одном блоке.

Это уже - оптимизация, влияющая на читаемость кода.
Она может её как улучшить, так и ухудшить, поэтому пытайтесь сохранить в первую очередь её (читаемость), и если она страдает слишком сильно, и всё слишком запутывается, а вам нужно отрисовать лишь десяток объектов - не используйте оптимизацию.
Ещё раз повторю: если у вас производительность не страдает - ставьте лёгкость понимания кода на первое место.
Кстати, это относится ко всему коду, а не только к ScreenLang.


Изображение:
image IMAGE
Где IMAGE - путь к изображению (применимо и то, что описывалось в соответствующей главе).

Тут следует упомянуть вот о чём.
Допустим, у вас есть что-то типа такого (упрощённо):
	image im.Scale('images/some_dir/some_name.png', 200, 100)
Так вот, не стоит так делать, лучше будет (не всегда, но в большинстве случаев) переписать это следующим образом:
	image 'images/some_dir/some_name.png':
		size (200, 100)
О свойстве size, как и о других общих свойствах, будет рассказано в конце этой главы.
Причина, почему это лучше - не будет создана ещё одна текстура, которая будет отличаться от оригинальной лишь размером.
Это - более оптимальное использование кэша (вы же ведь разобрались с ним и всё помните, не так ли?).
Во время отрисовки изображение будет растянуто так, как указано (если не указано, то растяжения/сжатия не будет).
Растяжение с помощью size (и подобными) почти совсем-совсем не сказывается на производительности.


imagemap и hotspot:
Можно лишь условно назвать imagemap контейнером, потому что единственный объект, который он может содержать - hotspot.
Он же, в свою очередь, может быть добавлен только в imagemap (а содержать вообще ничего не может).
Итак, imagemap виден как изображение, которое указано в его свойстве ground.
При наведении мыши на область, указанную в одном из hotspot'ов, поверх этой области рисуется (с использованием прозрачности) изображение, указанное свойством hover.
Свойства ground и hover очень похожи на соответствующие у кнопок.
Элемент hotspot имеет свою область в imagemap (x, y, ширина, высота) и свойство action (работает как в кнопках).
Пример использования:
imagemap:
	ground 'images/menu/ground.png'
	hover  'images/menu/hover.png'
	
	hotspot (50, 50, 200, 25) action Function(start_mod, 'main_game')
	hotspot (50, 75, 200, 25) action exit_from_game


vbox, hbox:
Это контейнеры, которые автоматически располагают элементы внутри себя (vbox - в столбец, hbox - в линию).
Имеют свойство spacing, которое определяет расстояние  между объектами (по-умолчанию 0).
Пример:
vbox:
	spacing 15
	
	textbutton "Играть"    action Function(start_mod, 'main_game')
	textbutton "Настройки" action ShowMenu('settings')
	textbutton "Выход"     action exit_from_game


null:
Ничто, пустота.
Имеет размеры: в отличие от Ren'Py, не width и height, а xsize и ysize (или сразу size, об этом позже).
Имена этих свойств изменены для большей логичности и стандартизации.
Может использоваться и в качестве контейнера.
Например, так можно сделать область в четверть экрана и расставить по её углам картинки:
null:
	size (0.5, 0.5)
	
	image img align (0.0, 0.0)
	image img align (0.0, 1.0)
	image img align (1.0, 0.0)
	image img align (1.0, 1.0)


screen:
Собственно, самый верхний узел во всей этой иерархии.
Имеет свойства has и use.
has позволяет превратить скрин в соответствующий авто-контейнер (has vbox или has hbox).
use позволяет включить указанный существующий скрин в текущий (например: use fps - включить скрин fps в текущий скрин).

Тут нужно учесть, что в текущей реализации каждый скрин может существовать только в одном экземпляре, тогда как в Ren'Py нередко используется включение скринов в циклах, что сейчас невозможно в Ren-Engine.
При этом, кстати, в скрины передаются параметры (что-то типа use some_screen('param1', 2 * i), например).
Этого тоже пока нет.

Кроме того, скрины в Ren'Py являются будто бы функциями (в смысле использования global в python).
В Ren-Engine такого нет. С одной стороны это хорошо (нельзя забыть написать global, потому что в этом нет необходимости), а с другой плохо - если в каком-то цикле, например, используется переменная path (как в примере из этой части), то после обновления экрана эта переменная продолжит существовать.
Плохо тут то, что, возможно, пользователь раньше приравнял эту переменную к какому-то значению и не ожидает, что она будет изменена внутри одного из скринов.
Точно также, как и может не ожидать того, что переменная _не_ изменится в Ren'Py, если не указать global.
Так что тут нет идеального решения, на мой взгляд.

Что касается use и передачи параметров - скорее всего, через некоторое время это будет реализовано.



Свойства:


alpha 0.75 # Непрозрачность (0 - полностью прозрачно, 1.0 - полностью видимо)


xpos 10 # координата по оси X в пикселях (0 - самая левая точка)
ypos 15 # Y-координата (0 сверху)
pos (10, 15) # более компактная форма записи 2-х предыдущих строк


xanchor 50 # X-координата в объекте, которая будет считаться началом, точкой отсчёта
Например, если xpos == 750, а xanchor == 650, то фактически объект будет рисоваться, начиная с X-координаты 100.
Аналогично для yanchor.
anchor (50, 75) # установка xanchor и yanchor одной строкой


xsize 100 # ширина объекта
ysize 50  # высота
size (100, 50) # установка xsize и ysize
Не стоит путать size с text_size, т. к. последнее отвечает за размер шрифта в текстовом поле.

Если размер не задан явно, то он вычисляется.
Размер vbox и hbox вычисляется так (на примере vbox):
	Длина - максимум среди длин всех вложенных объектов,
	Высота - сумма высот всех объектов + учёт расстояния (spacing) между ними.
Аналогично, но наоборот, вычисляется размер hbox.
Размер текстового поля вычисляется похожим образом, но вместо вложенных объектов там строки.


xalign 0.5 # размещение по центру оси X в родительском контейнере
yalign 1.0 # размещение снизу экрана
align (0.5, 1.0) # сокращённая запись
Как это работает:
	xalign  1.0
	# это сокращённая запись для:
	xpos    1.0 # помещаем в правый край экрана,
	xanchor 1.0 # ставим в качестве "нулевой точки" объекта его правый край
	# Т. е. мы ставим самый правый пиксель объекта в самый правый пиксель экрана

Если 0 < xpos < 1 или xpos == 1.0 (не целое (int) 1, а именно дробное (float) 1.0), то это значение умножается на длину окна.
В случае Y - на ширину окна.
Это действует на все эти группы свойств (pos, anchor, size).
Обратите внимание, что в случае с pos и size умножение идёт на длину и ширину _окна_, а не родительского контейнера.
Иначе такие штуки было бы непонятно как вычислять и их пришлось бы запретить:
hbox:
	textbutton "Click Me!" xsize 0.9
Т. к. 0.9 - относительно ширины родительского контейнера, но она зависит от ширины этой кнопки.
Хотя можно было считать, что все эти размеры просто равны нулю, но в этом не было бы абсолютно никакого смысла.
А если брать в расчёт не такие примитивные случаи, то мы бы получили ещё и кучу "магии", когда объект исчезает непонятно почему, непонятно куда и непонятно во что.
В случае с anchor - умножение идёт на размер текущего объекта.

Если число дробное, но меньше 0 или больше 1, то его дробная часть отбрасывается и оно считается целым.
Ведь, например, в такой строке:
xpos get_stage_width() * 0.2 # допустим, ширина окна сейчас равна 1000
Пользователь явно подразумевает, что объект должен быть помещён в X-координату 200, а никак не на 200 экранов правее начала отчёта.



Стили:

Если какое-то свойство объекта не задано в явной форме, то оно берётся из его стиля.
Они хранятся в объекте style (см. resources/mods/common/style.rpy).
Компонент типа text по-умолчанию имеет стиль text, image - стиль image и т. д.
Но можно создать свой стиль (как это сделать - см. в файле, что указан выше) и указать его, тогда недостающие свойства будут браться из него, а прежний стиль будет игнорироваться.
Указать стиль можно свойством style, например:
image 'some_image.png':
	style my_super_style # внимание, без кавычек!
	anchor (0.5, 0.5)
Но для этого стиль my_super_style должен быть создан как-то так:
	style.my_super_style = Style(style.image)
	style.my_super_style.xpos = 10
	style.my_super_style.ypos = 10
	style.my_super_style.xsize = 50
	style.my_super_style.ysize = 50
В файле style.rpy это написано, но на всякий случай повторю и тут:
Использовать в стилях свойства pos, anchor, xalign, yalign, align, size - нельзя.

В силу того, что стили редко изменяются (а по-хорошему они вообще не должны изменяться, по крайней мере - пока происходит отрисовка), значение каждого свойства берётся лишь один раз за кадр, далее при всех запросах в этом кадре к этому свойству будет использоваться именно кэшированное значение, полученное в первый раз.

Кстати, везде выше, где говорилось "не задано по-умолчанию" применительно к [x/y/]size, имелось ввиду "после вычисления результат <= 0".
А не то, что хранится в стиле по-умолчанию.
Т. е. если вы измените размер по-умолчанию в стиле, то можете легко поломать много вещей.
Поэтому подумайте трижды, прежде чем сделать это.

