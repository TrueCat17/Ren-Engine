Изображения.


Объявление:
Объявлять изображения можно в любой момент (главное - до их использования) и в init-блоке, и в label-секции.
Делается это так:
image np smile = "images/sprites/np/np_smile.png"
image np normal = "images/sprites/np/np_normal.png"

Путь к изображениям задаётся относительно директории resources.
При повторном определении старое изображение будет замещено новым.


Показ:

Отобразить изображение на экране можно командой show:
show np smile
Стоит обратить внимание на то, что если мы сейчас сделаем:
show np normal
То первое изображение пропадёт.
Это происходит из-за того, что они имеют один и тот же псевдоним.

Псевдоним указывается параметром as после имени изображения:
show np smile as np1
В случае же, когда мы не указываем его вручную, он автоматически приравнивается первому слову в имени изображения (в данном случае np).
Т. е. когда мы отображаем np normal, он получает такой же псевдоним, как и np smile, поэтому np smile убирается со сцены.

Также кроме as есть ещё параметры:

at указывает местоположение:
show np smile at left
show np smile at center
show np normal at fright
Допустимы следующие значения (слева направо): fleft, left, cleft, center, cright, right, fright (по-умолчанию используется center)
(На самом деле это специальные объекты, и вы можете создать свои, но об этом много позже...)

behind позволяет указать положение после какого-либо персонажа:
Допустим, у нас есть какой-то персонаж sp, и мы его отображаем так:
show sp normal at cright
Тогда при выполнении следующей команды персонаж np будет спереди sp:
show np normal at right
А если мы хотим поместить его позади, то следует использовать behind:
show np normal at right behind sp

Нужно отметить, что sp здесь является псевдонимом.
Т. е. если бы на пару строк выше sp был бы показан с использованием as sp1, то мы бы не получили желаемого, указав behind sp.

with указывает эффект, с которым отображается изображение (затемнение, появление и т. д.)
# Сейчас пока не реализовано


Скрытие:
hide np
Здесь np - псевдоним


Сцены:

Показ сцены убирает все объекты и показывает изображение нужной сцены. Примеры:
scene bg black
scene cg my_room



Более продвинутая работа с изображениями, im-функции:

im-функции позволяют проделывать с изображениями всякие хитрые (и не очень) вещи.
На вход они могут принимать путь до изображения и результат других функций (не только im, в отличие от Ren'Py).

Простейший пример - объединение нескольких картинок в одну:
image np smile = im.Composite((630, 1080), (0, 0), "images/sprites/np/body.png", (0, 0), "images/sprites/np/smile.png")

Пример чуть сложнее - изменение оттенков (перекраска):
image np unusual = im.MatrixColor("images/sprites/np/np_normal.png", im.matrix.tint(0.6, 0.2, 0.9))

Работают эти функции точно так же, как и в Ren'Py, поэтому описывать их тут слишком подробно не буду.
Дам лишь список im-функций (находятся в im):
MatrixColor - перекрашивает изображение,
Grayscale - в оттенки серого,
Sepia - сепия,
ReColor - упрощённый аналог MatrixColor, работает быстрее засчёт меньших (но частоиспользуемых) возможностей,
Color - другая форма вызова ReColor,
Alpha - задаёт прозрачность, использует для этого ReColor,
Flip - отражает изображения (по-горизонтали/по-вертикали/всё сразу),
Composite - объединяет несколько изображения в одно,
Scale - масштбирует до нужных размеров,
FactorScale - масштбирует изображение в N раз,
Crop - вырезает из изображения указанную часть.

И список функций для получения матриц для MatrixColor (находятся в im.matrix):
tint - обычная перепокраска,
saturation - насыщенность,
invert - инвертировать цвета,
brightness - яркость,
contrast - контраст,
opacity - прозрачность,
colorize - ещё 1 вид перекраски.

Со временем, возможно, появятся новые im-функции, вы сможете найти их в resources/mods/inc/im_functions.rpy


Технические подробности:

На самом деле, результат работы всех этих функций - строки, а не реальные изображения, поэтому работа со всем этим довольно быстра.

Также существует кэширование, поэтому если вы вдруг захотите нарисовать 1000 объектов в одной текстуре, то это будет сделано только один раз и только во время первой отрисовки (по крайней мере до тех пор, пока вы не измените хоть одну координату любого объекта и не попытаетесь отрисовать эту текстуру ещё раз).
Следует отличать команду показать картинку в последующих кадрах (show) и реальную отрисовку (image в ScreenLang).
Т. к. если вы добавите изображение в список отображения и тут же удалите, то часть движка, ответственная за текстуры, даже не узнает о том, что что-то изменилось.

И для примера рассмотрим упрощённый процесс отрисовки 2 изображений:
Пусть у нас есть:
image bus_stop_left = im.Crop(im.Scale("images/bg/bus_stop.jpg", 64, 45), (0, 0, 32, 45))
image bus_stop_right = im.Crop(im.Scale("images/bg/bus_stop.jpg", 64, 45), (32, 0, 32, 45))

!Внимание, это просто разбор того, что в данный момент происходит на самом деле.
!В будущем этот формат может быть изменён, поэтому если станете так писать, то потом, возможно, замучаетесь переписывать.
!Поэтому настоятельно рекомендую использовать именно im-функции.

Т. к. im-функции возвращают строки, то это примерно то же самое, что и
image bus_stop_left = "Crop (Scale (images/bg/bus_stop.jpg) 64 45) (0 0 32 45)"
image bus_stop_right = "Crop (Scale (images/bg/bus_stop.jpg) 64 45) (32 0 32 45)"

Теперь происходит попытка отрисовать всё в первый раз:
	При отрисовке текстуры для bus_stop_left:
	Запрашивается текстура "Crop (Scale (images/bg/bus_stop.jpg) 64 45) (0 0 32 45)".
		Вызывается Crop с параметрами (Scale (images/bg/bus_stop.jpg) 64 45) и (0 0 32 45).
			Запрашивается текстура "Scale (images/bg/bus_stop.jpg) 64 45".
				Вызывается Scale с параметрами images/bg/bus_stop.jpg, 64 и 45.
					Запрашивается текстура "images/bg/bus_stop.jpg".
						Загружается файл "images/bg/bus_stop.jpg".
							Результат сохраняется в кэше и возвращается.
					Масштабируется к размерам 64х45.
					Результат сохраняется в кэше и возвращается.
			Делается вырезка текстуры 32х45 из координат (0, 0).
			Результат сохраняется в кэше и возвращается.
	Готово.

	При отрисовке текстуры bus_stop_right:
	Запрашивается текстура "Crop (Scale (images/bg/bus_stop.jpg) 64 45) (32 0 32 45)".
		Вызывается Crop с параметрами (Scale (images/bg/bus_stop.jpg) 64 45) и (32 0 32 45).
			Запрашивается текстура "Scale (images/bg/bus_stop.jpg) 64 45".
			Такая текстура уже есть в кэше, поэтому она сразу берётся оттуда.
			Делается вырезка текстуры 32х45 из координат (32, 0).
			Результат сохраняется в кэше и возвращается.
	Готово.

При повторной отрисовке:
	При отрисовке текстуры для bus_stop_left:
		Запрашивается текстура "Crop (Scale (images/bg/bus_stop.jpg) 64 45) (0 0 32 45)".
		Такая текстура уже есть в кэше, поэтому она сразу берётся оттуда.
	Готово.
	
	Аналогично для bus_stop_right.

Но кэш не бесконечен, ясное дело (иначе ваша игра сожрала бы всю оперативку, и начались бы ужасные лаги из-за swap'а).
Его размер ограничен значениями в файле resources/params.conf.
Причём то, что описано выше - слегка упрощённый пример, текстуры используются не всегда.
Текстуры - это окончательные изображения, которые выводятся на экран, а до всего этого идёт работа с поверхностями (surface).
Сначала проверяется наличие изображения в кэше текстур, если оно есть - оно возвращается.
Если его нет:
	Оно запрашивается из кэша поверхностей.
	При запросе оно либо находится, либо создаётся, используя те поверхности, что уже существуют в кэше.
	Из найденной или созданной поверхности создаётся текстура и она возвращается.

К каждой текстуре привязана поверхность, из которой эта текстура создана, и поверхность не может быть удалена, пока используется текстура.
Если какой-либо из кэшей начинает занимать больше места, чем ему разрешено, то удаляется то изображение, которое запрашивалось как можно более длительный срок назад.
Если все изображения нужны для отрисовки текущего кадра, то ни одно из них не удаляется, и кэш продолжает занимать больше положенного...

Разумеется, чтобы просто брать и пользоваться движком, знать всё это не обязательно.
Но понимание устройства кэша и создания текстур поможет вам написать более быструю, производительную и менее требовательную игру.

