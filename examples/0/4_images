Изображения.


Объявление:
Объявлять изображения можно в любой момент (главное - до их использования) и в init-блоке, и в label-секции.
Делается это так:
image np smile = "images/sprites/np/np_smile.png"
image np normal = "images/sprites/np/np_normal.png"

Путь к изображениям задаётся относительно директории resources.
При повторном определении старое изображение будет замещено новым.


Показ:

Отобразить изображение на экране можно командой show:
show np smile
Стоит обратить внимание на то, что если мы сейчас сделаем:
show np normal
То первое изображение пропадёт.
Это происходит из-за того, что они имеют один и тот же псевдоним.

Псевдоним указывается параметром as после имени изображения:
show np smile as np1
В случае же, когда мы не указываем его вручную, он автоматически приравнивается первому слову в имени изображения (в данном случае np).
Т. е. когда мы отображаем np normal, он получает такой же псевдоним, как и np smile, поэтому np smile убирается со сцены.

Также кроме as есть ещё параметры:

at указывает местоположение:
show np smile at left
show np smile at center
show np normal at fright
Допустимы следующие значения (слева направо): fleft, left, cleft, center, cright, right, fright (по-умолчанию используется center)
(На самом деле это специальные объекты, и вы можете создать свои, но об этом много позже...)

behind позволяет указать положение после какого-либо персонажа:
Допустим, у нас есть какой-то персонаж sp, и мы его отображаем так:
show sp normal at cright
Тогда при выполнении следующей команды персонаж np будет спереди sp:
show np normal at right
А если мы хотим поместить его позади, то следует использовать behind:
show np normal at right behind sp

Нужно отметить, что sp здесь является псевдонимом.
Т. е. если бы на пару строк выше sp был бы показан с использованием as sp1, то мы бы не получили желаемого, указав behind sp.

with указывает эффект, с которым отображается изображение (затемнение, появление и т. д.).


Скрытие:
hide np
Здесь np - псевдоним


Сцены:

Показ сцены убирает все объекты и показывает изображение нужной сцены. Примеры:
scene bg black
scene cg my_room



Более продвинутая работа с изображениями, im-функции:

im-функции позволяют проделывать с изображениями всякие хитрые (и не очень) вещи.
На вход они могут принимать путь до изображения и результат других функций (не только im, в отличие от Ren'Py).

Простейший пример - объединение нескольких картинок в одну:
image np smile = im.Composite((630, 1080), (0, 0), "images/sprites/np/body.png", (0, 0), "images/sprites/np/smile.png")

Пример чуть сложнее - изменение оттенков (перекраска):
image np unusual = im.MatrixColor("images/sprites/np/np_normal.png", im.matrix.tint(0.6, 0.2, 0.9))

Работают эти функции точно так же, как и в Ren'Py, поэтому описывать их тут слишком подробно не буду.
Дам лишь список im-функций (находятся в im):
MatrixColor - перекрашивает изображение,
Grayscale - в оттенки серого, использует MatrixColor,
Sepia - сепия, использует MatrixColor,
ReColor - упрощённый аналог MatrixColor, работает в 2 раза быстрее засчёт меньших (но частоиспользуемых) возможностей,
Color - другая форма вызова ReColor,
Alpha - задаёт прозрачность, использует для этого ReColor,
Rotozoom - масштабирует изображение, затем поворачивает его (работает довольно медленно, но чем меньше размеры, тем быстрее),
Flip - отражает изображения (по-горизонтали/по-вертикали/всё сразу),
Composite - объединяет несколько изображения в одно,
Scale - масштбирует до нужных размеров,
FactorScale - масштбирует изображение в N раз,
Crop - вырезает из изображения указанную часть.

И список функций для получения матриц для MatrixColor (находятся в im.matrix):
tint - обычная перепокраска,
saturation - насыщенность,
invert - инвертировать цвета,
brightness - яркость,
contrast - контраст,
opacity - прозрачность,
colorize - ещё 1 вид перекраски.

Со временем, возможно, появятся новые im-функции, вы сможете найти их в resources/mods/common/im_functions.rpy

UPD:
Одна такая функция - im.Mask(image, mask, value, channel = 'r', cmp_func_name = 'le', alpha_channel = 'a', alpha_image = 1)
Cлужит для получения изображения по маске, работает это следующим образом:
	Проходимся по каждому пикселю, назовём текущий пиксель image - pixel_image, а соответствующий ему пиксель в mask - pixel_mask.
	Берём из pixel_mask канал channel (r, g, b или a) и сравниваем его значение (0-255) с value.
	Сравнение идёт с помощью функции cmp_func_name (l(<), g(>), e(==), ne(!=), le(<=), ge(>=)).
	Если условие выполняется, то rgb-каналы результирующего пикселя будут равны rgb-каналам image, а
		alpha-канал будет приравнен к каналу alpha_channel из пикселя pixel_image (при alpha_image == 1) или pixel_mask (при alpha_image == 2).
	Иначе результирующий пиксель будет пустым.
Функция im.AlphaMask реализована через im.Mask (параметры: image, mask, 0, 'r', 'g', 'r', 2).

Ещё есть im.Save(image, path, width = None, height = None) для сохранения image в путь path под размерами width x height.
	Если width или height являются None, то используется размер соответствующей стороны image.

Также, думаю, стоит обратить внимание на некоторую нелогичность: почему названия этих функций начинаются с большой буквы?
На самом деле, они начинаются с маленькой (т. е. всё как обычно), а названия с больших букв - это синонимы к названиям с маленькой.
Это сделано для совместимости с Ren'Py, т. к. там большинство этих сущностей являются классами внутри модуля im,
  тогда как здесь они являются именно функциями (статическими) внутри класса im.


Технические подробности:

На самом деле, результат работы всех этих функций - строки, а не реальные изображения, поэтому работа со всем этим довольно быстра.

Также существует кэширование, поэтому если вы вдруг захотите нарисовать 1000 объектов в одной текстуре,
то это будет сделано только один раз и только во время первой отрисовки,
по крайней мере до тех пор, пока вы не измените хоть одну координату любого объекта и не попытаетесь отрисовать эту текстуру ещё раз.
Следует отличать команду показать картинку в последующих кадрах (show) и реальную отрисовку (image в ScreenLang).
Т. к. если вы добавите изображение в список отображения и тут же удалите, то часть движка,
ответственная за текстуры, даже не узнает о том, что что-то изменилось.

И для примера рассмотрим упрощённый процесс отрисовки 2 изображений:
Пусть у нас есть:
image bus_stop_left = im.Crop(im.Scale("images/bg/bus_stop.jpg", 64, 45), (0, 0, 32, 45))
image bus_stop_right = im.Crop(im.Scale("images/bg/bus_stop.jpg", 64, 45), (32, 0, 32, 45))

!Внимание, это просто разбор того, что в данный момент происходит на самом деле.
!В будущем этот формат может быть изменён, поэтому если станете так писать, то потом, возможно, замучаетесь переписывать.
!Поэтому настоятельно рекомендую использовать именно im-функции.

Т. к. im-функции возвращают строки, то это примерно то же самое, что и
image bus_stop_left = "Crop (Scale (images/bg/bus_stop.jpg) 64 45) (0 0 32 45)"
image bus_stop_right = "Crop (Scale (images/bg/bus_stop.jpg) 64 45) (32 0 32 45)"

Теперь происходит попытка отрисовать всё в первый раз:
	При отрисовке текстуры для bus_stop_left:
	Запрашивается текстура "Crop (Scale (images/bg/bus_stop.jpg) 64 45) (0 0 32 45)".
		Вызывается Crop с параметрами (Scale (images/bg/bus_stop.jpg) 64 45) и (0 0 32 45).
			Запрашивается текстура "Scale (images/bg/bus_stop.jpg) 64 45".
				Вызывается Scale с параметрами images/bg/bus_stop.jpg, 64 и 45.
					Запрашивается текстура "images/bg/bus_stop.jpg".
						Загружается файл "images/bg/bus_stop.jpg".
							Результат сохраняется в кэше и возвращается.
					Масштабируется к размерам 64х45.
					Результат сохраняется в кэше и возвращается.
			Делается вырезка текстуры 32х45 из координат (0, 0).
			Результат сохраняется в кэше и возвращается.
	Готово.

	При отрисовке текстуры bus_stop_right:
	Запрашивается текстура "Crop (Scale (images/bg/bus_stop.jpg) 64 45) (32 0 32 45)".
		Вызывается Crop с параметрами (Scale (images/bg/bus_stop.jpg) 64 45) и (32 0 32 45).
			Запрашивается текстура "Scale (images/bg/bus_stop.jpg) 64 45".
			Такая текстура уже есть в кэше, поэтому она сразу берётся оттуда.
			Делается вырезка текстуры 32х45 из координат (32, 0).
			Результат сохраняется в кэше и возвращается.
	Готово.

При повторной отрисовке:
	При отрисовке текстуры для bus_stop_left:
		Запрашивается текстура "Crop (Scale (images/bg/bus_stop.jpg) 64 45) (0 0 32 45)".
		Такая текстура уже есть в кэше, поэтому она сразу берётся оттуда.
	Готово.
	
	Аналогично для bus_stop_right.

UPD:
	Как и говорилось выше, формат может быть изменён, что и произошло.
	Пробелы между аргументами команд были заменены на символ | (вертикальная черта).
	Это было сделано для того, чтобы пробелы стали доступны внутри пути к изображениям.
	Возможно, в будущем такое будет ещё происходить ещё не один раз, и
	именно поэтому настоятельно рекомендуется использовать im-функции и не составлять эти строки в ручную.

Но кэш не бесконечен, ясное дело (иначе ваша игра сожрала бы всю оперативку, и начались бы ужасные лаги из-за swap'а).
Его размер ограничен значениями в файле resources/params.conf.
Причём то, что описано выше - слегка упрощённый пример, текстуры используются не всегда.
Текстуры - это окончательные изображения, которые выводятся на экран, а до всего этого идёт работа с поверхностями (surface).
Сначала проверяется наличие изображения в кэше текстур, если оно есть - оно возвращается.
Если его нет:
	Оно запрашивается из кэша поверхностей.
	При запросе оно либо находится, либо создаётся, используя те поверхности, что уже существуют в кэше.
	Из найденной или созданной поверхности создаётся текстура и она возвращается.

К каждой текстуре привязана поверхность, из которой эта текстура создана, и поверхность не может быть удалена, пока используется текстура.
Если какой-либо из кэшей начинает занимать больше места, чем ему разрешено, то удаляется то изображение, которое запрашивалось как можно более длительный срок назад.
Если все изображения нужны для отрисовки текущего кадра, то ни одно из них не удаляется, и кэш продолжает занимать больше положенного...

Кстати, если вам нужно загрузить изображение, которое уже загружалось,
но после этого было изменено, то можете добавить после пути к нему "?some_text".
Это "?some_text" считается за часть имени текстуры, но отбрасывается непосредственно при загрузке файла.
Например, вы можете использовать изображение "images/some_image.png?" + str(os.path.getmtime("images/some_image.png"))
В этом случае, если изображение "images/some_image.png" было изменено после того, как было загружено, то оно автоматически перезагрузится.
Это произойдёт из-за того, что os.path.getmtime возвращает время изменения файла, т. е. после изменения изображения будет запрашиваться уже другая текстура с тем же путём к изображению (а путь указывается до знака '?').
Такой приём, например, используется в скринах сохранения и загрузки, т. к. при перезаписи уже существующего сохранения скриншот старого сохранения становится неактуальным и нужна только последняя версия скриншота.

Разумеется, чтобы просто брать и пользоваться движком, знать всё это не обязательно.
Но понимание устройства кэша и создания текстур поможет вам написать более быструю, производительную и менее требовательную игру.

