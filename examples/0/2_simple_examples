Простейшие примеры.


Регистрация персонажей:
np = Character("Новая Персона", unknown_name = "Неизвестная Персона", color = "#FF8000")

Имя np в начале приравнивается к "Новая Персона".
unknown_name используется после вызова функции make_names_unknown().
Также задать имя можно функцией set_name (она же meet):
meet(np, "Прохожий")
Оригинальное название можно вернуть, вызвав make_names_known().


Реплики:
np "Привет!"
np "5 + 5 = " + str(5 + 5)

Продолжение реплики:
np "1 + 2 = "
extend str(5 + 5) + "!"

В репликах допустимы теги курсива (i), "полужирности" (b), подчёркивания (u), зачёркивания (s), указания цвета (color) и паузы (w).
Теги могут быть как угодно вложены друг в друга.
Пауза может иметь время (в секундах), после которого она прекратится.
np "Текст1{w=1}-Текст2{w=3.5}-Конец."

Если время не установлено, то оно считается равным бесконечности.
Пауза любой продолжительности может быть пропущена нажатием <Enter> или <Space>.
Цвет задаётся 16-ричным кодом в формате RGB без префиксов (как # и 0x), кавычек и чего бы то ни было ещё.

np "Сколько {s}{color=FFFFFF}зим{/color}{/s} {color=00AA00}лет{/color} мы с тобой не виделись!"
np "Здравствуйте, я {s}Кирилл{/s} " + str(np) + ". {w}{i}Суть такова{/i}... {w}Я {b}джва{/b} года хочу такую игру!"

Как видно из 2-х последних примеров, слишком большое количество тегов скорее навредит тексту, чем приукрасит его.
Используйте их вмеру.

Кстати, строка с репликой:
np some_str
Делает то же самое, что и:
$ np(some_str)
Т. е. персонаж тут используется в качестве вызываемого объекта (у объекта вызывается функция __call__ с параметром some_str).


Питон-код:

Код для питона можно выполнить 2 способами.
Как одну строку (такие начинаются со знака $):
$ print min(123 * 432, 234 * 321)
Или как блок python-кода:
python:
	def pm(a, b):
		print a * b
	
	pm(33, 45)


Условия:
Тут всё как в питоне.

$ a = 3 + 4
if a < 5:
	np "Да это же наглая ложь!"
elif a == 5:
	np "3 + 4 == 5? {w=1.5}Серьёзно?"
elif a > 10:
	np "Теперь в другую сторону перегнули..."
else:
	# Только эта ветка будет выполнена, т. к. все предыдущие условия оказались не верны
	np "Верно."

!!!
Ни в коем случае нельзя путать приравнивание:
a = 3
Со сравнением:
a == 3


Циклы:
Опять же, всё как в питоне.

np "Я считаю до 5."
np "Не могу до 10."
np ""
for i in xrange(5):
	extend str(i) + " "
extend "- с рифмой с детства я дружу!"

Даже continue, break и else есть:
$ a = [3, 1, 4, 8, 5, 2, 6]
for i in a:
	if i <= 2:
		continue
	if i > 7:
		break
	np "Ещё одно подходящее число найдено. Это " + str(i)
else:
	np "Кажется, тут не было чисел больше 7, потому что break не был использован..."

С while ситуация аналогичная, поэтому приведу только простейший пример:
$ i = 1
$ f = 1
while i <= 7:
	$ f *= i
	$ i += 1
np "Факториал 7 = " + str(f)


jump и call:
Позволяют прыгнуть на нужную метку.
jump после завершения метки возвращает в меню (если auto_exit не установлена в False, но это уже другая история...)
Для последующего возврата нужно использовать call вместо jump, это их единственное различие.

# Допустим, мы сейчас на этой метке
label cur_label:
#	...
	jump need_label
	
	me "А этих слов я уже никогда не скажу."
	me "А если я их уже говорю, значит парой строк выше jump был коварно заменён на call."

label need_label:
	me "Ну вот мы и тут."
#	...
	me "Вот уже и конец метки."

Кстати, тут показаны комментарии: всё, что находится после # - игнорируется (как и в питоне)

Если имя метки нужно вычислить, то можно использовать expression после jump/call:
jump expression "end_root_" + random.choice(cur_root_names)


return:
Прекращает выполнение текущей метки, будто текущая команда в ней была последней.


pass:
Ничего не делает.


window:
Тут всё как в Ren'Py.
Операции с диалоговым окном.
Так можно скрыть его:
window hide
А так - показать:
window show

Так же есть питон-функции для перевода окна в nvl/adv режимы:
$ set_mode_adv() # Обычный режим. Следующая реплика удалит ту, что видна сейчас. Текст снизу экрана.
$ set_mode_nvl() # Следующая реплика будет идти ниже текущей. Текст начинается сверху экрана.

Очищать экран от реплик в nvl-режиме нужно так:
nvl clear
Если этого не делать, то довольно быстро текст будет отображаться так низко, что его нельзя будет увидеть (ниже границы окна игры).


Меню выбора:

$ energy = 10
$ skills = 4
me "Куда бы мне пойти?":
menu:
	"Никуда, останусь сидеть дома.":
		pass
	"На работу пора." if skills > 0 else None:
		$ energy -= 5
		$ skills += 1
	"В парк!" if energy > 2 else None:
		$ energy -= 2
		jump day2_park_meet

Как можно заметить, некоторые пункты меню можно не отображать (в отличии от Ren'Py тут требуется else None для этого).
Если результат равен None, то пункт меню не отображается, но если это пустая строка, то получается зазор между пунктами.
Если что, res1 if cond else res2 - обычная питоновская конструкция:
print "3 меньше 4." if 3 < 4 else "Ловите наркомана!"


Паузы:

Из питона:
$ renpy.pause(1.5)
Командой:
pause 1.5

Внимание, пауза идёт ПОСЛЕ исполнения текущей команды, а не после строки вызова паузы:
python:
	renpy.pause(5)
	print "Эта строка будет выведена сразу же."
me "А вот эта - через 5 секунд."

Сделано это для того, чтобы как можно скорее освободить python от исполнения этой команды.
Нужно помнить, что python - штука однопоточная, поэтому если он встанет на паузу, то графический интерфейс тоже перестанет обновляться, ведь ему требуется питон для вычисления свойств визуальных объектов (позиция, размеры, условия, действия и т. д.)
Если же вам и вправду нужно, чтобы ваше приложение в прямом смысле зависло на некоторое время, используйте функцию time.sleep(1.5)

Также любая пауза может быть промотана нажатием <Enter> или <Space>.
Параметра hard (непропускаемость паузы) здесь не существует.
Всегда ненавидел смотреть слайдшоу по 1.5 минуты без возможности пропуска.
Если вы хотите к себе тонны ненависти - можете прикрутить этот hard, у меня бы ушло на это не больше 15 минут, но я берегу вас как могу.



Самое важное, запуск игры:

Перед тем, как говорить непосредственно о запуске игры, следует дать определение понятию "Мод".
Мод - это папка с rpy-файлами и нужными этому моду ресурсами.
Имя мода - это имя папки, в которой находятся файлы этого мода.
Понятия "мод" и "непосредственно сама игра" объединены в одно для того, чтобы не создавать новые понятия там, где в этом нет необходимости.
Ведь основная игра может делать ровно то же самое, что и моды.

Все моды лежат в resources/mods/
В начале игры запускается мод основного меню main_menu.
Из него происходит переход к другим модам (например, к основной игре или к какому-то дополнению, и проч.)

Q: Зачем нужно деление модов на директории, почему нельзя свалить их все в одну кучу?
A: Потому что:
	1. В этой куче будет сложно что-то найти, если понадобится.
	2. Возможно замещение ресурсов одного мода ресурсами другого.
	3. При использовании одних и тех же имён переменных/меток/скринов моды могут конфликтовать друг с другом.
	Поэтому каждый мод лежит в своей папке, и в один момент времени может быть запущен только один мод.
	Также это хорошо сказывается на времени запуска (можно установить хоть 1000 модов, время запуска любого из них будет таким, будто он один).

Q: А если мне не нужно главное меню?
A: Можно запустить нужный мод сразу в init-блоке главного меню.
	init -200000000:
		# Низкий приоритет для того, чтобы не ждать выполнения других init-блоков.
		$ start_mod("my_super_game")

Q: Что происходит при запуске мода?
A:	1. Происходит парсинг (разбор) всех rpy-файлов в папке мода и в папке inc,
	2. Выполняются все init-блоки в нужном порядке,
	3. Добавляются все скрины, имена которых перечислены через пробел в start_screens (по-умолчанию "locations sprites dialogue_box"),
	4. Происходит переход на нужную метку (label).
	
	Порядок инициализации определяется приоритетом, аналогично Ren'Py. Чем ниже приоритет, тем раньше запустится init-блок.
	Например, зададим значение в одном блоке, а используем в другом.
	init -1:
		$ a = 4
		$ b = 56
	init 0:
		$ print a, b
	Если поменять приоритеты (0 и -1) местами, то получим ошибку о несуществовании переменных, которые хотим использовать.
	
	Кстати, init-блоки могут быть полностью питон-кодом, т. е. первый блок из прошлого примера можно переписать так:
	init -1 python:
		a = 4
		b = 56

	Имя метки берётся из объекта mods, поэтому в init-блоке обычно делается
	init:
		$ mods["start_main_menu"] = "main_menu"
		# start_main_menu - название метки, на которую будет осуществлён переход.
		# main_menu - имя мода ( = папки).



Некоторые полезные функции:

out_msg("from", "error_description") # вывод сообщений/ошибок в окне (не в консоли)
get_mods() # словарь (dict) модов в виде {имя:начальная_метка}

start_mod("mod_name") # запуск мода mod_name
exit_from_game() # немедленный выход из игры

get_stage_width() # ширина окна игры
get_stage_height() # высота

get_texture_width("image_path") # ширина текстуры
get_texture_height("image_path")

get_fps() # получить максимальное значение фпс (FPS, Frame Per Second, количество кадров в секунду)
set_fps() # установить максимальное значение фпс

get_image_code("image name") # получить "значение" изображения, зарегистрированного командой image (см. след. главу)

show_screen("screen_name") # показать скрин с именем screen_name
hide_screen("screen_name") # скрыть

Также много интересного можно найти в resources/mods/inc/renpy_api.rpy.

