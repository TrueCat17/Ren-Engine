РПГ-функции.


В этой части рассказывается об управлении локациями и персонажами в RPG-игре.
Если у вас игра другого стиля, то (скорее всего) вам не понадобится абсолютно ничего из того, что здесь описывается.


Все указанные здесь функции написаны на питоне и использоваться могут только в нём.
Если имя аргумента функции указано в кавычках, то функция ожидает, что этот аргумент будет строкой.


Игра заканчивается, когда выполнены все команды стартовой метки (в том числе все команды запущеных из неё меток).


Локация и персонажи отображаются всегда на самом дальнем плане.
Следовательно, bg и cg (фоны) в скрине sprites всегда закрывают локацию и персонажей, если существуют.


Переключение между локациями:
$ set_location("location_name", "place_name")
Где place_name - имя места в локации location_name.
Перед показом новой локации удаляются все объекты,
  добавленные функцией add_location_object и автоматически добавляется ГГ (me, Семён) в место place_name.

Скрытие локации:
$ hide_location()

Регистрация локации:
register_location("location_name", "path_to_images", is_room, width, height)
Где location_name - имя локации,
    path_to_images - путь к каталогу с картинками (png) локаций (относительно каталога мода),
    	Имена этих картинок:
    		main.png - основное изображение,
    		over.png - изображение с тем, что находится сверху и под чем персонажи могут проходить,
    			Может отсутствовать.
    		free.png - изображение, где доступные для передвижения места закрашены цветом #000000FF (полностью чёрный и непрозрачный).
    			Может отсутствовать, тогда персонаж может ходить где угодно.
    is_room - является ли данная локация помещением (True) или улицей (False)
    	Влияет на масштабирование локации
    width - ширина картинки main.png локации, целое число
   	height - высота картинки main.png локации, целое число

Регистрация места в локации:
$ register_place("location_name", "place_name", x, y)
Где location_name - имя локации,
    place_name - имя места,
    x и y - координаты (числа, без кавычек) места в локации (в пикселях).

Регистрация выхода из локации:
$ register_exit("location_name", "to_location_name", "to_place_name", x, y)
Где location_name - имя локации, в которой располагается выход,
    to_location_name - имя локации, в которую будет произведён переход,
    to_place_name - имя места, в которое будет произведён переход,
    x и y - координаты (числа, без кавычек) места в локации (в пикселях).


В любом месте сценария:
	cur_location_name будет являться названием текущей локации,
	cur_place_name - названием текущего места в ней (или None, если игрок слишком далеко от всех зарегистрированных мест).

Перед переходом на какую-либо локацию выполняется функция can_exit_to(to_location_name, to_place_name).
	to_location_name - имя локации, в которую осуществляется переход,
	to_place_name - имя места в этой локации.
Если она возвращает True - переход осуществляется, иначе - нет.
Эта функция определяется пользователем движка (т. е. разработчиком игры или мода), если её нет, то считается, что она всегда возвращает True.

После перехода в локацию с именем "some_location" выполняется метка on__some_location.
При перемещении персонажа в зону определённого места "some_place" в локации "some_location" (зарегистрированного с помощью register_place)
выполняется метка, имя которой возвращает функция get_place_label.
Эта функция тоже определяется пользователем, если такой функции нет, то имя метки принимается за some_location__some_place.
Если внутри зоны "some_place" в локации "some_location" нажата "кнопка действия" (по-умолчанию - "E"),
то выполняется метка some_location__some_place.
	Переменная exec_action в этом случае будет равна True (иначе - False).
Если метки с каким-либо именем на этих пунктах не существует - ничего не делается.

Описанное в 2 предыдущих абзацах выполняется в метке "rpg_update", она сама себя не вызовет, это нужно делать пользователю.
Например, так:
label start:
	call prologue
	
	while True:
		call rpg_update
		pause 0.2


Квесты - раз у нас игра в стиле rpg, то, конечно же, у нас есть и квесты.
Для активации квеста нужно запустить функцию quest_start с нужным квестом:
	$ quest_start("some_quest")
Этим:
	some_quest будет добавлен в список активных квестов,
	Ему будет дано имя из переменной some_quest__name (или "some_quest", если такой переменной нет),
	Будет вызвана метка some_quest__start, если она есть.
При переходе в локацию или место в локации (или при нажатии "кнопки действия" в месте), будет переход на метку
	some_quest__on__location__place, где:
		some_quest - квест,
		location - имя текущей локации,
		place - имя текущего места.
Если существует несколько активных квестов, у каждого из которых есть соответствующая метка, то игроку будет показано меню,
в котором он сможет выбрать наиболее приоритетный в данный момент квест.
Для завершения квеста нужно вызвать quest_end:
	$ quest_end("some_quest")
Эта функция аналогично quest_start вызывает some_quest__end (если есть) после удаления.

Также следует отметить, что перед переходом на some_quest__on__location__place
у игрока отбирается контроль над персонажем и показывается диалоговое окно.
После завершения метки контроль возвращается, а диалоговое окно убирается.
По некоторым причинам (см. renpy.call в предыдущей части) это не касается меток some_quest__start и some_quest__end.


# Пока не реализовано.
Добавление фоновых звуков в локацию (пение птиц, нажатие на клавиатуру и т. д.):
$ add_ambience("location_name", "ambience_path")
Где location_name - имя локации, в которую добавляется фоновый звук,
    ambience_path - путь к проигрываемому файлу.

Регистрация персонажей:
$ character.make_rpg("prefix_path_to_image", "dress")
Где character - персонаж, который уже создан (nc = Character("NewCharacter", color="0x0000FF")),
    prefix_path_to_image - часть пути к картинке 240x384, на которой в 4 ряда (строки) расположены 5 кадров (столбцы) на каждый поворот:
    	Кадры:
	    	1, 2, 3, 4 - ходьба/бег,
	    	2, 4 - стойка,
	    	5 - сидячее положение.
	    Ряды:
	    	{1, 2, 3, 4} - соответственно {на нас, налево, направо, от нас}.
	dress - Начальная одежда.
	    
    Целый путь до картинки вычисляется как prefix_path_to_image + dress + '.png'.
    Где dress - одежда на персонаже ('pi', 'sw' и т. д.), задаваемая функцией set_dress.

Отображение персонажа character в текущей локации в месте place_name:
$ show_character(character, "place_name")

Скрытие персонажа character на карте:
$ hide_character(character)

Принудительное передвижение персонажа:
$ character.move_to_place("place_name", is_run = False, end_stop_time = -1)
Где character - персонаж,
    place_name - название места, в которое он передвигается
    	Или список мест, в этом случае можно в конце списка указать индекс в этом списке, на который будет переход в конце цикла,
    is_run - True (если бежит) или False (если идёт).
    exec_stop_time - время (в сек.), на которое выполнение сценария ставится на паузу.
    	Если меньше 0 (по-умолчанию), то пауза продлится до тех пор, пока персонаж не дойдёт до нужного места.
    	Если больше или равно 0, то пауза продлится указанное время:
    		Если время уже вышло, а персонаж ещё не дошёл, то происходит переход к следующей команде,
    		Если время ещё не вышло, а персонаж уже дошёл до конца, то пауза всё равно продлится указанное время.
Это передвижение можно "перемотать", нажав на Tab:
	Использовать здесь Пробел/Enter нельзя, т. к. они уже используются при перемотке текста,
	 и по некоторым техническим причинам корректно совместить это нельзя.

Поворот персонажа:
$ character.set_direction(direction)
Где character - персонаж,
    direction - направление: to_forward (от нас), to_back (на нас), to_left(влево), to_right(вправо):
    	На самом деле direction - число, а {to_forward, to_back, to_left, to_right} - переменные, равные {3, 0, 1, 2} соответственно
    	Но использовать напрямую числа вместо переменных не рекомендуется:
    		В будущем цифры могут быть изменены, тогда как имена переменных останутся прежними.

Смена положения:
$ character.set_pose("pose")
Где character - персонаж,
    pose - поза, допустимы:
    	"sit" - сидеть,
    	"stance" - стоять.

Смена одежды на "need_dress":
$ character.set_dress("need_dress")

Сказать камере следить не за ГГ, а за другим персонажем/местом в локации:
$ cam_to(obj)
Где obj - персонаж, за которым будет следовать камера,
	или имя места в текущей локации, за которым будет вестись наблюдение.

Вернуть камеру на следование за ГГ, если что, можно так:
$ cam_to(me)
Что, вроде, логично.

Регистрация объекта для отображения в локации:
$ register_location_object("obj_name", "path_to_main_image", "path_to_free_image" = None, max_in_inventory_cell = 0, remove_to_location = True)
Где obj_name - название регистрируемого объекта, который будет отображаться в локации,
    path_to_main_image - путь к изображению,
    path_to_free_image - путь к изображению "карты проходимости",
    	Аналогично такой же у локаций, т. е. персонаж может передвигаться в полностью чёрных зонах,
    	Если отсутствует, то двигаться можно везде.
    max_in_inventory_cell - максимальное кол-во таких объектов в одной ячейке инвентаря (если меньше 1, то в инвентарь взять нельзя),
    remove_to_location - True - если при "удалении" из инвентаря объект возвращается на карту, False - если просто удаляется.

Добавление объекта в локацию:
$ add_location_object("location_name", place, "obj_name")
Где location_name - имя локации, в которую добавляется объект,
    place:
    	Имя места в локации, в которое будет поставлен объект,
    	Или объект (например, dict) со свойствами x и y, обозначающми координаты точки, в которую будет добавлен объект.
    obj_name - название зарегистрированного (с помощью register_location_object) объекта, который будет отображаться в локации,

Удаление объекта с именем "obj_name" с локации:
$ remove_location_object("location_name", place, "obj_name", count = 1)
Здесь count - кол-во ближайших к place объектов, которые нужно удалить с локации:
	Если указано больше, чем существует, то оставшееся игнорируется.

Положить объект в инвентарь можно нажатием "кнопки действия" рядом с объектом.
Берётся ближайший объект, которые можно взять в инвентарь.
Эта операция имеет приоритет над "действием" в определённом месте локации (см. выше).

Объект в инвентаре можно:
	Использовать:
		Тогда вызывается метка вида some_quest__obj_name для активного квеста, у которого будет такая метка,
		Если найдётся несколько подходящих меток, то у пользователя будет меню для выбора нужного ему квеста,
		"Использованный" объект не удаляется из инвентаря (но его может удалить вызванная метка).
	Удалить (вернуть в локацию или совсем удалить, в зависимости от параметра remove_to_location при регистрации).

