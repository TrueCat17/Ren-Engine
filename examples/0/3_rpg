РПГ-функции.


В этой части рассказывается об управлении локациями и персонажами в RPG-игре.
Если у вас игра другого стиля, то (скорее всего) вам не понадобится абсолютно ничего из того, что здесь описывается.


Все указанные здесь функции написаны на питоне и использоваться могут только в нём.
Если имя аргумента функции указано в кавычках, то функция ожидает, что этот аргумент будет строкой.


Игра заканчивается, когда выполнены все команды стартовой метки (в том числе все команды запущеных из неё меток).


Локация и персонажи отображаются всегда на самом дальнем плане.
Следовательно, bg и cg (фоны) в скрине sprites всегда перекрывают rpg-объекты, если существуют.


Переключение между локациями:
$ set_location("location_name", place)
Где place - имя места в локации location_name или словарь (dict) со свойствами x, y, xsize и ysize.
При показе локации автоматически добавляется ГГ (me, Семён) в центр места place.

Скрытие локации:
$ hide_location()

Регистрация локации:
register_location("location_name", "path_to_images", is_room, xsize, ysize)
Где location_name - имя локации,
	path_to_images - путь к каталогу с картинками (png) локаций (относительно каталога мода),
		Имена этих картинок:
			main.png - основное изображение,
			over.png - изображение с тем, что находится сверху и под чем персонажи могут проходить,
				Может отсутствовать,
			free.png - изображение, где доступные для передвижения места закрашены цветом 0x000000FF (полностью чёрный и непрозрачный),
				Может отсутствовать, тогда персонаж может ходить где угодно,
		Ожидается, что размеры всех этих картинок будут одинаковы,
	is_room - является ли данная локация помещением (True) или улицей (False),
		Влияет на масштабирование локации,
	xsize - ширина картинки main.png локации, целое число,
	ysize - высота картинки main.png локации, целое число.

Регистрация места в локации:
$ register_place("location_name", "place_name", x, y, ysize, xsize)
Где location_name - имя локации,
	place_name - имя места,
	x, y - координаты (числа) места в локации (отступ в пикселях от левого верхнего угла main.png),
	xsize, ysize - ширина и высота (числа) места (в пикселях).

Регистрация выхода из локации:
$ register_exit("location_name", "to_location_name", "to_place_name", x, y, xsize, ysize)
Где location_name - имя локации, в которой располагается выход,
	to_location_name - имя локации, в которую будет произведён переход,
	to_place_name - имя места, в которое будет произведён переход,
	x, y - координаты (числа) места в локации (отступ в пикселях от левого верхнего угла main.png),
	xsize, ysize - ширина и высота (числа) выхода (в пикселях).


В любом месте сценария:
	cur_location_name будет являться названием текущей локации,
	cur_place_name - названием текущего места в ней (или None, если игрок слишком далеко от всех зарегистрированных мест).

Перед переходом на какую-либо локацию выполняется функция can_exit_to(to_location_name, to_place_name):
	to_location_name - имя локации, в которую осуществляется переход,
	to_place_name - имя места в этой локации.
Если она возвращает True - переход осуществляется, иначе - нет.
Эта функция определяется пользователем движка (т. е. разработчиком игры или мода), если её нет, то считается, что она всегда возвращает True.

После перехода в локацию с именем "some_location" выполняется метка on__some_location.
При перемещении персонажа в зону определённого места "some_place" в локации "some_location" (зарегистрированного с помощью register_place) выполняется метка, имя которой возвращает функция get_place_label("some_location", "some_place").
Эта функция тоже определяется пользователем, если такой функции нет, то имя метки принимается за some_location__some_place.
Если внутри зоны "some_place" в локации "some_location" нажата "кнопка действия" (по-умолчанию - "E"), то выполняется метка some_location__some_place:
	Переменная exec_action в этом случае будет равна True (иначе - False).
Если метки с каким-либо именем на этих пунктах не существует - ничего не делается.

Описанное в 2 предыдущих абзацах выполняется в метке с циклом событий "rpg_loop", она сама себя не вызовет, это нужно делать пользователю.
Например, так:
label start:
	call my_prologue
	call rpg_loop

Этот цикл в rpg_loop бесконечен (while True), поэтому вызов rpg_loop должен быть последним.
Слово "цикл" употребляется здесь не просто так.
В нём обнаруживаются события (вроде "игрок подошёл к такому-то месту"), вызывается соответствующая метка.
После этого управление опять возвращается в этот цикл.
Это важно знать, чтобы ни в каких метках RPG-игры не использовать jump, ведь после него управление не возвращается, и игра заканчивается.


Квесты - раз у нас игра в стиле rpg, то, конечно же, у нас есть и квесты.
Для активации квеста нужно запустить функцию quest_start с нужным квестом:
	$ quest_start("some_quest")
Этим:
	some_quest будет добавлен в список активных квестов,
	Ему будет дано имя из переменной some_quest__name (или "some_quest", если такой переменной нет),
	Будет вызвана метка some_quest__start, если она есть.
При переходе в локацию или место в локации (или при нажатии "кнопки действия" в месте), будет переход на метку
	some_quest__on__location__place, где:
		some_quest - квест,
		location - имя текущей локации,
		place - имя текущего места.
Если существует несколько активных квестов, у каждого из которых есть соответствующая метка, то игроку будет показано меню,
в котором он сможет выбрать наиболее приоритетный в данный момент квест.
Для завершения квеста нужно вызвать quest_end:
	$ quest_end("some_quest")
Эта функция аналогично quest_start вызывает some_quest__end (если есть) после удаления.
Узнать, запущен ли квест some_quest, можно функцией quest_started("some_quest"):
	Она вернёт True, если запущен, иначе False.

Также следует отметить, что перед переходом на some_quest__on__location__place
у игрока отбирается контроль над персонажем и показывается диалоговое окно.
После завершения метки контроль возвращается, а диалоговое окно убирается.
По некоторым причинам (см. renpy.call в предыдущей части) это не касается меток some_quest__start и some_quest__end.


# Пока не реализовано.
Добавление фоновых звуков в локацию (пение птиц, нажатие на клавиатуру и т. д.):
$ add_ambience("location_name", "ambience_path")
Где location_name - имя локации, в которую добавляется фоновый звук,
	ambience_path - путь к проигрываемому файлу.

Регистрация персонажей:
$ ch.make_rpg("directory", "rpg_name", "start_dress")
Где ch - персонаж, который уже создан (ch = Character("NewCharacter", color="0x0000FF")),
	directory - часть пути к картинке 240x384, на которой в 4 ряда (строки) расположены 5 кадров (столбцы) на каждый поворот:
		Кадры:
			1, 2, 3, 4 - ходьба/бег,
			2, 4 - стойка,
			5 - сидячее положение.
		Ряды:
			{1, 2, 3, 4} - соответственно {на нас, налево, направо, от нас}.
	rpg_name - имя персонажа в пути к RPG-спрайту (вроде me, dv, mt и т. д.),
	start_dress - Начальная одежда.
	
	Целый путь до картинки вычисляется как directory + rpg_name + '_' + dress + '.png'.
	Где dress - одежда на персонаже ('pioneer', 'swim' и т. д.), задаваемая функцией set_dress.

Регистрация анимации у персонажа:
$ register_character_animation(character, anim_name, path, xoffset, yoffset,
	                           count_frames, start_frame, end_frame, time = 1.0)
Где character - персонаж, у которого регистрируется анимация,
    anim_name - название регистрируемой анимации,
    path - путь к изображению (без расширения) анимации (кадры в ряд),
    xoffset, yoffset - отступ относительно обычного состояния,
    count_frames - количество кадров в изображении,
    start_frame - начальный кадр анимации,
    end_frame - последний кадр анимации (включительно),
    time - время, за которое анимация будет закончена.

Отображение персонажа character в текущей локации в месте place_name:
$ show_character(character, "place_name", location = None)
Если локация не указывается, то она принимается за текущую.

Скрытие персонажа character на карте:
$ hide_character(character)

Принудительное передвижение персонажа:
$ character.move_to_place("place_name", is_run = False, end_stop_time = -1)
Где character - персонаж,
	place_name - название места, в которое он передвигается
		Или список мест, в этом случае можно в конце списка указать индекс в этом списке, на который будет переход в конце цикла,
	is_run - True (если бежит) или False (если идёт).
	exec_stop_time - время (в сек.), на которое выполнение сценария ставится на паузу.
		Если меньше 0 (по-умолчанию), то пауза продлится до тех пор, пока персонаж не дойдёт до нужного места.
		Если больше или равно 0, то пауза продлится указанное время:
			Если время уже вышло, а персонаж ещё не дошёл, то происходит переход к следующей команде,
			Если время ещё не вышло, а персонаж уже дошёл до конца, то пауза всё равно продлится указанное время.
Это передвижение можно "перемотать", нажав Пробел/Enter или кликнув по фону или кнопке "Далее".

Поворот персонажа:
$ character.set_direction(direction)
Где character - персонаж,
	direction - направление: to_forward (от нас), to_back (на нас), to_left(влево), to_right(вправо):
		На самом деле direction - число, а {to_forward, to_back, to_left, to_right} - переменные, равные {3, 0, 1, 2} соответственно
		Однако использовать напрямую числа вместо переменных - плохая идея.

Смена положения:
$ character.set_pose("pose")
Где character - персонаж,
	pose - поза, допустимы:
		"sit" - сидеть,
		"stance" - стоять.

Смена одежды на "need_dress":
$ character.set_dress("need_dress")

Сказать камере следить не за ГГ, а за другим персонажем/местом в локации:
$ cam_to(obj, moving_time = 1.0)
Где obj - персонаж,
          имя места в текущей локации или
          dict со свойствами x и y (и опционально xsize = 0 и ysize = 0), например {'x': me.x, 'y': my.y - 100},
        за которым будет вестись наблюдение,
    moving_time - время перемещения камеры от текущего объекта наблюдения до нового.

Вернуть камеру на следование за ГГ, если что, можно так:
$ cam_to(me)
Что, вроде, логично.

Регистрация объекта для отображения в локации:
$ register_location_object("obj_name", "directory", "main_image", "free_image",
                           max_in_inventory_cell = 0, remove_to_location = True)
Где obj_name - название регистрируемого объекта, который будет отображаться в локации,
	directory - путь к директории изображений,
	main_image - основное изображение объекта (в directory) без точки с расширением (.png),
	free_image - изображение "карты проходимости",
		Аналогично такой же у локаций, но персонаж может передвигаться только вне чёрных зон (у локаций - только внутри),
		Если отсутствует (None), то двигаться можно везде.
	max_in_inventory_cell - максимальное кол-во таких объектов в одной ячейке инвентаря (если меньше 1, то в инвентарь взять нельзя),
	remove_to_location - True - если при "удалении" из инвентаря объект возвращается на карту, False - если просто удаляется.

Путь до изображения объекта вычисляется так:
	image_path = directory + main_image + '.png'
Для карты проходимости вместо main_image берётся free_image.

Регистрация анимации у объекта:
$ register_location_object_animation("obj_name", "anim_name", "directory", "main_image", "free_image",
                                     xpos, ypos, 
                                     count_frames, start_frame, end_frame, time = 1.0)
Где obj_name - название объекта локации, для которого регистрируется анимация,
    anim_name - название регистрируемой анимации,
    directory - путь к директории изображений,
    main_image - основное изображение с одинаковыми по размеру кадрами, расположенными горизонтально друг за другом (без расширения),
    free_image - изображение с кадрами "карты проходимости", так же расположенными друг за другом (без расширения),
    	Если они не одинаковы, то прохождение по ним игрока во время их смены нежелательно,
    xpos, ypos - отступ относительно обычного состояния,
    count_frames - количество кадров в main_image,
    start_frame - начальный кадр анимации,
    end_frame - последний кадр анимации (включительно),
    time - время, за которое анимация будет закончена.

Путь до изображения с кадрами вычисляется аналогично пути к основному изображению (см. абзац выше).

Добавление объекта в локацию:
$ add_location_object("location_name", place, "obj_name")
Где location_name - имя локации, в которую добавляется объект,
	place:
		Имя места в локации, в которое будет поставлен объект,
		Или объект (например, dict) со свойствами x и y (опционально xsize = 0, ysize = 0),
			обозначающми координаты (и размеры) места, в которое будет добавлен объект.
	obj_name - название зарегистрированного (с помощью register_location_object) объекта, который будет отображаться в локации,

Получить список из count ближайших объектов типа obj_name:
$ get_location_objects("location_name", place, "obj_name", count = -1)
Где location_name - имя локации, на которой ищутся объекты:
		Название текущей локации лежит в переменной cur_location_name.
	place:
		Имя места в локации, рядом с которым будет искаться объект,
		Или объект (например, dict) со свойствами x и y, обозначающми координаты точки, в которую будет добавлен объект.
Если obj_name == None, то тип объекта игнорируется.
Если count < 0, то вернётся список всех объектов указанного типа.
Если нужных объектов будет меньше count, результат будет аналогичен с count == -1.

Запуск анимации у объекта локации:
$ obj.start_animation("anim_name", speed = 1.0, repeat = 0)
Где obj - объект локации из списка, полученного вызовом get_location_objects,
	anim_name - имя зарегистрированной анимации,
	speed - скорость воспроизведения относительно указанной при регистрации:
		если speed == 0, отображаться будет только начальный кадр анимации,
		если speed < 0, то только финальный.
	repeat определяет кол-во повторов после первого воспроизведения:
		если repeat == 0, повторов не будет,
		если repeat < 0, повторы будут длиться до тех пор, пока анимации не будет удалена или заменена.

Удаление анимации (возврат к обычному изображению):
$ obj.remove_animation()
Где obj - объект локации из списка, полученного вызовом get_location_objects.

Удаление объекта с именем "obj_name" с локации:
$ remove_location_object("location_name", place, "obj_name", count = 1)
Здесь count - кол-во ближайших к place объектов, которые нужно удалить с локации:
	Если указано больше, чем существует, то оставшееся игнорируется.

Положить объект в инвентарь можно нажатием "кнопки действия" рядом с объектом.
Берётся ближайший объект, которые можно взять в инвентарь.
Эта операция приоритетнее "действия" в определённом месте локации (см. выше).

Объект в инвентаре можно:
	Использовать:
		Тогда вызывается метка вида some_quest__on__using__obj_name для активного квеста, у которого будет такая метка,
		"Использованный" объект не удаляется из инвентаря (но его может удалить вызванная метка).
	Удалить (вернуть в локацию или совсем удалить, в зависимости от параметра remove_to_location при регистрации):
		После вызовется метка вида some_quest__on__remove__obj_name для активного квеста, у которого будет такая метка.
После взятия объекта вызовется метка вида some_quest__on__taking__obj_name для активного квеста, у которого будет такая метка.
Если найдётся несколько подходящих меток, то у пользователя будет меню для выбора нужного ему квеста,
  если же нужной не найдётся ни одной, то ничего не вызывается.

Указать размер инвентаря (кол-во ячеек):
$ set_inventory_size(30)

Функция add_to_inventory(obj_name, count) добавляет в инвентарь count объектов типа obj_name и возвращает кол-во объектов,
которые нельзя поместить из-за ограничений по размеру инвентаря.

has_in_inventory(obj_name, count) возвращает True, если в инвентаре имеется count объектов типа obj_name, иначе - False.

remove_from_inventory(obj_name, count) удаляет из инвентаря count объектов типа obj_name и
возвращает кол-во объектов, которые нельзя удалить из-за их отсутствия.

